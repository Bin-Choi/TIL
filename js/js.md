## JavaScript 
>> Web 기술의 기반이 되는 언어
- HTML문서의 콘텐츠를 동적으로 변경할 수 있는 언어
- Web이라는 공간에서 채팅, 게임 등 다양한 동작을 할 수 있게 된 기반

>> 웹 브라우저의 역할
- URL을 통해 Web(WWW)을 탐색함
- `HTML` `CSS` `JavaScript`를 이해한 뒤 해석해서 사용자에게 하나의 화면으로 보여줌
- 웹 서비스 이용 시 클라이언트의 역할을 함
- 즉, 웹 페이지 코드를 이해하고, 보여주는 역할을 하는 것이 웹 브라우저


## JavaScript 기초 문법
<hr>
## 코드 작성법
>> 세미콜론(semicolon)
- 자바스크립트는 세미콜론을 선택적으로 사용 가능
- 세미콜론이 없으면 ASI에 의해 자동으로 세미콜론이 삽입됨

>> 들여쓰기와 코드 블럭
- 2칸 들여쓰기
- 블럭(block)은 if, for, 함수에서 중괄호 `{ }`내부를 말함
    - python은 들여쓰기를 이용해서 코드 블럭을 구분
    - JavaScript는 중괄호 `{}`를 사용해 코드 블럭을 구분
```JavaScript
if (isClean) { // 중괄호를 사용해서 코드 블럭 구분
  console.log('clean!') // 2칸 들여쓰기
}
```

>> 주석
- 한 줄 주석(`//`)과 여러 줄(`/* */`) 주석

>> 식별자 정의와 특징
- 식별자(identifier)는 변수를 구분할 수 있는 변수명을 말함
- 식별자는 반드시 문자, 달러($) 또는 밑줄(_)로 시작
- 대소문자를 구분하며, 클래스명 외에는 모두 소문자로 시작
- 예약어 사용 불가능
    - 예약어 예시: for, if, functhion 등

- 카멜 케이스(camelCase, lower-camel-case)
    - 변수, 객체, 함수에 사용

- 파스칼 키에스 (PascalCase, upper-camel-case)
    - 클래스, 생성자에 사용

- 대문자 스네이크 케이스(SNAKE_CASE)
    - 상수(constants)에 사용
    - 상수: 개발자의 의도와 상관없이 변경될 가능성이 없는 값을 의미

>> 변수 선언 키워드
- Python과 다르게 JavaScript는 변수를 선언하는 키워드가 정해져 있음
    1. `let`
        - 블록 스코프 지역 변수를 선언 (추가로 동시에 값을 초기화)
    2. `const`
        - 블록 스코프 읽기 전용 상수를 선언 ( 추가로 동시에 값을 초기화)
    3. `var`
        - 변수를 선언 (추가로 동시에 값을 초기화)

>> [참고] 선언, 할당, 초기화
- 선언 (Declaration)
    - 변수를 생성하는 행위 또는 시점
- 할당 (Assignment)
    - 선언된 변수에 값을 저장하는 행위 또는 시점
- 초기화 (Initialization)
    - 선언된 변수에 처음으로 값을 저장하는 행위 또는 시점

>> [참고] 블록 스코프 (block scope)
- if, for, 함수 등의 중괄호 (`{}`) 내부를 가리킴
- 블록 스코프를 가지는 변수는 블록 바깥에서 접근 불가능

>> let
- 재할당 가능 & 재선언 불가능
- 블록 스코프를 갖는 지역 변수를 선언, 선언과 동시에 원하는 값으로 초기화 할 수 있음

>> const
- 재할당 불가능 & 재선언 불가능
- 선언 시 반드시 초기값을 설정 해야 하며, 이후 값 변경이 불가능
- `let` 과 동일하게 블록 스코프를 가짐

>> var
- 재할당 가능 & 재선언 가능
- "호이스팅" 되는 특성으로 인해 예기치 못한 문제 발생 가능
- 함수 스코프(function scope)를 가짐

>> [참고] 호이스팅 (hoisting)
- 변수를 선언 이전에 참조할 수 있는 현상
- `var`로 선언된 변수는 선언 이전에 참조할 수 있으며, 이러한 현상을 호이스팅이라 함
- 변수 선언 이전의 위치에서 접근 시 undefined를 반환
- 변수를 선언하기 전에 접근이 가능한 것은 코드의 논리적인 흐름을 깨뜨리는 행위이며 이러한 것을 방지하기 위해 `let`, `const`가 추가되었음
    - 즉 `var`는 사용하지 않아야 하는 키워드

>> 데이터 타입
- JavaScript의 모든 값은 특정한 데이터 타입을 가짐
- 크게 원시 타입(Primitive type)과 참조 타입(Referencs type)으로 분류됨

>> Number
- 정수 또는 실수형 숫자를 표현하는 자료형
- NaN
    - Not-A-Number(숫자가 아님)를 나타냄
- Number.isNaN() 의 경우 주어진 값이 유형이 Number이고 값이 NaN이면 true, 아니면 false를 반환
    - (NaN , /0 )이면 true 거의다 false
- NaN을 반환하는 경우
    1. 숫자로서 읽을 수 없음
    2. 결과가 허수인 수학 계산식
    3. 피연산자 NaN (7**NaN)
    4. 정의할 수 없는 계산식 (0 * Infinity)
    5. 문자열을 포함하면서 덧셈이 아닌 계산식 ("가" / 3)

>> String
- 문자열을 표현하는 자료형
- 작은 따옴표 또는 큰 따옴표 모두 가능
- 곱셈, 나눗셈, 뺄셈은 안되지만 덧셈을 통해 문자열 붙일 수 있음
- Quote를 사용하면 선언 시 줄 바꿈이 안됨
- 대신 escape sequence를 사용할 수 있기 때문에 \n를 사용해야 함
- `Template Literal`를 사용하면 줄 바꿈이 되며, 문자열 사이에 변수도 삽입도 가능
- (단, escape sequence를 사용할 수 없다) == Python의 "f-string"
 
>> Template literals (템플릿 리터럴)
- 내장된 표현식을 허용하는 문자열 작성 방식
- Backtick(``)을 이용하며, 여러 줄에 걸쳐 문자열을 정의할 수도 있고 JavaScript의 변수를 문자열 안에 바로 연결할 수 있는 이점이 생김
- 표현식을 넣을 수 있는데, 이는 $와 중괄호 ($  {expression} )로 표기

>> Empty Value 
- 값이 존재하지 않음을 표현하는 값으로 JavaScript에서는 `null`, `undefined` 가 존재
- 동일한 역할을 하는 이 두개의 키워드가 존재하는 이유는 단순한 JavaScript의 설계 실수
- 큰 차이를 두지 말고 interchangeable 하게 사용할 수 있도록 권장함

>> null 
- `null`값을 나타내는 특별한 키워드
- 변수의 값이 없음을 의도적으로 표현할 때 사용하는 데이터 타입

>> undefined
- 값이 정의되어 있지 않음을 표현하는 값
- 변수 선언 이후 직접 값을 할당하지 않으면 자동으로 할당됨

>> null 과 Undefined
- null 과 undefined의 가장 대표적인 차이점은 typeof 연산자를 통해 타입을 확인 했을 때 나타남
- null >> `object`
- undefined >> `undefined`

- null이 원시 타입임에도 불구하고 object로 출력되는 이유는 JavaScript 설계 당시의 버그를 지금까지 해결하지 못한 것

>> Boolean
- `true`와 `false`
- 조건문 또는 반복문에서 유용하게 사용
     - 조건문 또는 반복문에서 boolean이 아닌 데이터 타입은 자동 형변환 규칙에 따라 `true` 또는 `false`로 변환됨

## 연산자
>> 할당 연산자
- 오른쪽에 있는 피연산자의 평가 결과를 왼쪽 피연산자에 할당하는 연산자

>> 비교 연산자
- 피연산자들을 비교하고 결과값을 boolean으로 반환

>> 동등 연산자 (==)
- 비교할 때 암묵적 타입 변환 통해 타입을 일치시킨 후 같은 값인지 비교
- 두 피연산자가 모두 객체일 경우 메모리의 같은 객체를 바라보는지 판별
- 예상치 못한 결과가 발생할 수 있으므로 특별한 경우를 제외하고 사용하지 않음

>> 일치 연산자 (===)
- 두 피연산자의 값과 타입이 모두 같은 겨웅 true를 반환
- 같은 객체를 가리키거나, 같은 타입이면서 같은 값인지를 비교

>> 논리 연산자
- 세 가지 논리 연산자로 구성
- 단축 평가 지원

&& -> and
or -> ||

>> 삼항 연산자
- 3개의 피연산자를 사용하여 조건에 따라 값을 반환하는 연산자
- 가장 앞의 조선식이 참이면 : (콜론) 앞의 값이 반환되며, 그 반대일 경우 : 뒤의 값이 반환되는 연산자
- 삼항 연산자의 결과 값이기 때문에 변수에 할당 가능

## 조건문
>> 조건문의 종류와 특징
- if statement
    - 조건 표현식의 결과값을 boolean 타입으로 변환 후 참/거짓을 판단
- switch statement
- 조건 표현식의 결과값이 어느 값(case)에 해당하는지 판별
- 주로 특정 변수의 값에 따라 조건을 분기할 때 활용
    - 조건이 많아질 경우 if문보다 가독성이 나을 수 있음

>> if statement
- if, else if, else
    - 조건은 소괄호`()`안에 작성
    - 실행할 코드는 중괄호`{}`안에 작성
    - 블록 스코프 생성

>> switch statement
- 표현식의 결과값의 이용한 조건문
- 표현식의 결과값과 case문의 오른쪽 값을 비교
- break 및 default문은 [선택적]으로 사용 가능
- break 문이 없는 경우 break문을 만나거나 default문을 실행할 때까지 다음 조건문 실행
- 블록 스코프 생성

## 반복문
>> 반복문 종류
- while
- for
- for...in
- for...of

>> while 
- 조건문이 참이기만 하면 문장을 계속해서 수행
>> for
- 특정한 조건이 거짓으로 판별될 때까지 반복
>> for ... in
- 객체의 속성을 순회할 때 사용
- 배열도 순회 가능하지만 인덱스 순으로 순회한다는 보장이 없으므로 권장하지 않음
>> for ... of
- 반복 가능한 객체를 순회할 때 사용
- 반복 가능한 (iterable) 객체의 종류: Array, Set, String 등

>> for ... in 과 for ... of  차이
- for ... in 은 "속성 이름"을 통해 반복
- for ... of 는 "속성 값"을 통해 반복

```JavaScript
const arr = [3, 5, 7]

for (const i in arr) {
    console.log(i) // 0 1 2
}

for (const i of arr) {
    console.log(i) // 3 5 7
}
```

- for문
``` JavaScript
for (let i = 0; i < arr.length; i++) {...}
```
최초 정의한 `i`를 재할당 하면서 사용하기 때문에 const를 사용하면 에러 발생

- for ...in, for ...of

재할당이 아니라, 매 반복 시 해당 변수를 새로 정의하여 사용하므로 에러가 발생하지 않음

## 함수의 정의
>> 함수 선언식
- 일반적인 프로그래밍 언어의 함수 정의 방식

>> 함수 표현식
- 표현식 내에서 함수를 정의하는 방식
- 함수 표현식은 함수의 이름을 생략한 익명 함수로 정의 가능
- 표현식에서 함수 이름을 명시하는 것도 가능 (이 경우 함수 이름은 호출에 사용 되지 못하고 디버깅 용도로 사용)

>> 기본 인자
- 인자 작성 시 '=' 문자 뒤 기본 인자 선언 가능
>> 매개변수와 인자의 개수 불일치 허용

ㅇㅇ
>> Spread syntax(`...`)

- 전개 구문을 사용하면 배열이나 문자열과 같이 반복 가능한 객체를 배열의 경우는 요소, 함수의 경우는 인자로 확장할 수 있음

1. 배열과의 사용 (배열 복사)
2. 함수와의 사용 (Rest parameters)
    - 정해지지 않은 수의 매개변수를 배열로 받을 수 있음

## 선언식과 표현식
>> 호이스팅 - 선언식
- 함수 선언식으로 정의한 함수는 `var`로 정의한 변수처럼 호이스팅이 발생
- 즉 함수 호출 이후에 선언해도 동작
>> 호이스팅 - 표현식
- 함수 표현식으로 선언한 함수는 함수 정의 전에 호출 시 에러 발생
- 함수 표현식으로 정의된 함수는 변수로 평가되어 변수의 scope 규칙을 따름

## Arrow Function

